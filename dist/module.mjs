import { defineNuxtModule, createResolver, resolveAlias, useLogger, addComponent, addImports, addTemplate, extendPages, resolveModule } from '@nuxt/kit';
import JSAPI from 'svgo/lib/svgo/jsAPI.js';
import { optimize } from 'svgo';

function inlineDefs(document, params) {
  const defs = document.querySelector("defs");
  const uses = document.querySelectorAll("use");
  if (!uses) {
    return document;
  }
  const useCount = _countUses(uses);
  for (let i = 0; i < uses.length; i++) {
    let hrefItem = uses[i].attr("xlink:href");
    if (!hrefItem) {
      hrefItem = uses[i].attr("href");
    }
    const href = hrefItem.value;
    if (params.onlyUnique === true && useCount[href] > 1) {
      continue;
    }
    const x = uses[i].hasAttr("x") ? uses[i].attr("x").value : null;
    const y = uses[i].hasAttr("y") ? uses[i].attr("y").value : null;
    let attrValue = null;
    if (x && y) {
      attrValue = "translate(" + x + ", " + y + ")";
    } else if (x) {
      attrValue = "translate(" + x + ")";
    }
    let def = _findById(defs, href.match(idRegex)[1]);
    if (!def) {
      continue;
    }
    if (params.onlyUnique === true && useCount[href] === 1) {
      def = _replaceElement(def);
    }
    for (const key in uses[i].attrs) {
      if (Object.prototype.hasOwnProperty.call(uses[i].attrs, key) && key !== "x" && key !== "y" && key !== "xlink:href" && key !== "href") {
        def.addAttr(uses[i].attrs[key]);
      }
    }
    if (attrValue) {
      const g = new JSAPI({
        elem: "g",
        attrs: {
          transform: {
            name: "transform",
            value: attrValue,
            prefix: null,
            local: "transform"
          }
        },
        content: [def]
      });
      _replaceElement(uses[i], g);
    } else {
      _replaceElement(uses[i], def);
    }
  }
  if (params.onlyUnique === false) {
    for (const element in useCount) {
      if (Object.prototype.hasOwnProperty.call(useCount, element) && useCount[element] > 1) {
        const tags = document.querySelectorAll(element);
        for (let j = 0; j < tags.length; j++) {
          tags[j].removeAttr("id");
        }
      }
    }
  }
  _removeDefs(document, params);
  return document;
}
function _removeDefs(document, params) {
  if (params.onlyUnique === false || document.querySelector("defs").children.length === 0) {
    _replaceElement(document.querySelector("defs"));
  }
}
function _countUses(elements) {
  return elements.reduce(function(result, item) {
    let hrefItem = item.attr("xlink:href");
    if (!hrefItem) {
      hrefItem = item.attr("href");
    }
    const href = hrefItem.value;
    if (Object.prototype.hasOwnProperty.call(result, href)) {
      result[href]++;
    } else {
      result[href] = 1;
    }
    return result;
  }, {});
}
function _replaceElement(oldElement, newElement = null) {
  const elementIndex = _getElementIndex(oldElement);
  if (newElement) {
    oldElement.parentNode.spliceContent(elementIndex, 1, newElement);
  } else {
    oldElement.parentNode.spliceContent(elementIndex, 1);
  }
  return oldElement;
}
function _getElementIndex(element) {
  element.addAttr({
    name: "data-defs-index",
    value: "true",
    prefix: "",
    local: "data-defs-index"
  });
  const index = element.parentNode.children.findIndex(function(contentElement) {
    return contentElement.hasAttr("data-defs-index", "true");
  });
  element.removeAttr("data-defs-index");
  return index;
}
const idRegex = /^#?(\S+)/;
function _findById(element, id) {
  if (element.hasAttr("id", id)) {
    return element;
  }
  if (element.children) {
    for (let i = 0; i < element.children.length; i++) {
      const result = _findById(element.children[i], id);
      if (result !== null) {
        return result;
      }
    }
  }
  return null;
}
const inlineDefs$1 = {
  name: "inlineDefs",
  type: "full",
  active: true,
  description: "inlines svg definitions",
  params: {
    onlyUnique: false
  },
  fn: inlineDefs
};

const spritesTemplate = {
  filename: "svg-sprite.mjs",
  getContents({ options }) {
    const imports = Object.keys(options.sprites).map((sprite) => `  "${sprite}": () => import("${options.outDir}/${sprite}.svg").then(r => r.default || r)`).join(",\n");
    return [
      "// Generated by @nuxtjs/svg-sprite",
      "export const sprites = {",
      imports,
      "}",
      'export const spriteClass = "";\n',
      'export const spriteClassPrefix = "";\n',
      `export const defaultSprite = "${options.defaultSprite}";
`
    ].join("\n");
  }
};
const iconsTemplate = {
  filename: "svg-sprite-icons.mjs",
  getContents({ options }) {
    const imports = Object.keys(options.sprites).map((name) => ({
      name,
      symbols: options.sprites[name].map((svg) => ({
        name: svg.name,
        key: `${options.defaultSprite === name ? "" : `${name}/`}${svg.name}`
      }))
    }));
    return [
      "// Generated by @nuxtjs/svg-sprite",
      `export const icons = ${JSON.stringify(imports, null, 2)}
`
    ].join("\n");
  }
};

function useSvgFile(file) {
  if (file.startsWith("svg:")) {
    file = file.substring(4);
  }
  const paths = file.split(":");
  const name = paths.pop().replace(/\.svg$/, "").toLocaleLowerCase().replace(/[^a-z0-9-]/g, "-");
  const sprite = paths.join("-");
  return {
    name,
    sprite
  };
}
function createSpritesManager(svgoOptions = {}) {
  const sprites = {};
  const addSvg = async (svg) => {
    svg = await optimizeSVG(svg, svgoOptions).then(extractDefs).then(convertToSymbol);
    sprites[svg.sprite] = (sprites[svg.sprite] || []).filter((s) => s.name !== svg.name);
    sprites[svg.sprite].push(svg);
  };
  const removeSvg = (sprite, name) => {
    sprites[sprite] = sprites[sprite] || [];
    sprites[sprite] = sprites[sprite].filter((s) => s.name !== name);
    if (sprites[sprite].length === 0) {
      delete sprites[sprite];
    }
  };
  const removeSprite = (sprite) => {
    delete sprites[sprite];
  };
  const generateSprite = (sprite) => {
    if (!sprites[sprite]) {
      return "";
    }
    const defs = sprites[sprite].map((svg) => svg.defs || "").join("");
    const contents = sprites[sprite].map((svg) => svg.content);
    return [
      '<?xml version="1.0" encoding="UTF-8"?>',
      '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">',
      `<defs>${defs}</defs>`,
      ...contents,
      "</svg>"
    ].join("\n");
  };
  return {
    sprites,
    addSvg,
    removeSvg,
    removeSprite,
    generateSprite
  };
}
function convertToSymbol(svg) {
  return {
    ...svg,
    content: svg.content.replace("<svg", `<symbol id="${svg.name}"`).replace("</svg>", "</symbol>").replace(/<defs>(.+)<\/defs>/, "")
  };
}
function extractDefs(svg) {
  return {
    ...svg,
    defs: svg.content.match(/<defs>(.+)<\/defs>/)?.[1] || ""
  };
}
async function optimizeSVG(svg, optimizeOptions = {}) {
  const plugins = optimizeOptions.plugins || [];
  const presetDefault = plugins.find((p) => p.name === "preset-default");
  presetDefault.params.overrides.cleanupIDs = {
    ...presetDefault.params.overrides.cleanupIDs,
    prefix: `${svg.name}-`
  };
  const $data = await optimize(svg.content, optimizeOptions);
  return {
    ...svg,
    content: $data.data
  };
}

const module = defineNuxtModule({
  meta: {
    name: "@nuxtjs/svg-sprite",
    configKey: "svgSprite",
    compatibility: {
      bridge: true
    }
  },
  defaults: {
    input: "~/assets/sprite/svg",
    output: "~/assets/sprite/gen",
    defaultSprite: "icons",
    iconsPath: "/_icons",
    optimizeOptions: {
      plugins: [
        {
          name: "preset-default",
          params: {
            overrides: {
              removeViewBox: false,
              inlineStyles: {
                onlyMatchedOnce: false
              },
              cleanupIDs: {}
            }
          }
        },
        { name: "removeXMLNS", active: true },
        { name: "removeDimensions" },
        {
          name: "removeAttrs",
          params: {
            attrs: "svg:id"
          }
        },
        inlineDefs$1
      ]
    }
  },
  async setup(options, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const resolveRuntimeModule = (path) => resolveModule(path, { paths: resolve("./runtime") });
    const outDir = resolveAlias(options.output, nuxt.options.alias);
    const logger = useLogger("svg-sprite");
    await addComponent({ name: "SvgIcon", filePath: resolve("./runtime/components/component.vue"), global: true });
    await addImports({ name: "useSprite", as: "useSprite", from: resolveRuntimeModule("./composables/useSprite") });
    const { sprites, addSvg, removeSvg, generateSprite } = createSpritesManager(options.optimizeOptions);
    nuxt.options.alias["#svg-sprite"] = addTemplate({
      ...spritesTemplate,
      options: {
        sprites,
        outDir,
        defaultSprite: options.defaultSprite
      }
    }).dst;
    if (options.iconsPath) {
      nuxt.options.alias["#svg-sprite-icons"] = addTemplate({
        ...iconsTemplate,
        options: {
          sprites,
          outDir,
          defaultSprite: options.defaultSprite
        }
      }).dst;
      extendPages((routes) => {
        routes.unshift({
          name: "icons-page",
          path: options.iconsPath,
          file: resolve("runtime/components/icons-page.vue")
        });
      });
    }
    nuxt.hook("nitro:config", (nitro) => {
      const assetsFS = {
        driver: "fs",
        path: "test",
        base: outDir
      };
      if (!nitro.storage) {
        nitro.storage = {};
      }
      nitro.storage.svgs = assetsFS;
    });
    nuxt.hook("nitro:init", async (nitro) => {
      const input = options?.input?.replace(/~|\.\//, "root").replace(/\//g, ":") ?? "";
      const output = "svgs";
      if (!await nitro.storage.hasItem(`${output}:.gitignore`)) {
        await nitro.storage.setItem(`${output}:.gitignore`, "*");
      }
      const svgs = await nitro.storage.getKeys(input).then((keys) => keys.map((key) => key.substring(input.length + 1)));
      await Promise.all(
        svgs.map(async (file) => {
          const { name, sprite } = useSvgFile(file);
          return addSvg({
            name,
            sprite: sprite || options.defaultSprite,
            content: await nitro.storage.getItem(`${input}:${file}`)
          });
        })
      );
      const writeSprite = (sprite) => nitro.storage.setItem(`${output}:${sprite}.svg`, generateSprite(sprite));
      await Promise.all(Object.keys(sprites).map(writeSprite));
      if (!nuxt.options.dev) {
        return;
      }
      const handleFileChange = async (event, file) => {
        if (!file.startsWith(input)) {
          return;
        }
        file = file.substring(input.length + 1);
        const { name, sprite } = useSvgFile(file);
        if (event === "update") {
          logger.log(`${file} changed`);
          await addSvg({
            name,
            sprite: sprite || options.defaultSprite,
            content: await nitro.storage.getItem(`${input}:${file}`)
          });
        } else if (event === "remove") {
          logger.log(`${file} removed`);
          removeSvg(sprite, name);
        }
        await writeSprite(sprite || options.defaultSprite);
      };
      nitro.storage.watch((event, file) => handleFileChange(event, file));
    });
  }
});

export { module as default };
